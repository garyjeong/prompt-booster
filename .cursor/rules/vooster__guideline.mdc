---
description:
globs:
alwaysApply: true
---
# Prompt Booster Code Guidelines

## 1. Project Overview

Prompt Booster is a lightweight web application built with Next.js that enhances prompts for AI coding assistants. It aims to improve developer productivity by optimizing prompts for better AI responses. The application uses a serverless architecture and stores data locally in the browser.

Key architectural decisions:

-   **Next.js**: For SSR/SSG, routing, and API handling.
-   **TypeScript**: For static typing and code quality.
-   **Chakra UI**: For rapid UI development with reusable components.
-   **LocalStorage**: For client-side data persistence.
-   **Serverless Functions**: For API endpoints interacting with OpenAI/Gemini.

## 2. Core Principles

-   **Maintainability**: Code should be easy to understand, modify, and debug.
-   **Performance**: Application should respond quickly and efficiently.
-   **Readability**: Code should be clear and self-documenting.
-   **Testability**: Code should be designed to be easily tested.
-   **Consistency**: Follow established patterns and conventions throughout the project.

## 3. Language-Specific Guidelines

### TypeScript

#### File Organization and Directory Structure

-   Group related files into feature-based directories.
-   Use PascalCase for component filenames (e.g., `PromptInput.tsx`).
-   Use camelCase for function and variable names.

#### Import/Dependency Management

-   Use absolute imports for project modules (e.g., `import PromptInput from 'components/PromptInput'`).
-   Install dependencies using `npm install` or `yarn add`.
-   Keep `package.json` clean and up-to-date.

#### Error Handling Patterns

-   Use `try...catch` blocks for handling potential errors in asynchronous operations (e.g., API calls).
-   Implement error boundaries for catching errors in React components.
-   Log errors with sufficient context for debugging.

```typescript
// MUST: Example of try...catch for API calls
async function fetchPrompt(prompt: string) {
    try {
        const response = await fetch('/api/improve', {
            method: 'POST',
            body: JSON.stringify({ prompt }),
            headers: { 'Content-Type': 'application/json' },
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data.improvedPrompt;
    } catch (error: any) {
        console.error('Failed to fetch prompt:', error);
        // Handle the error appropriately (e.g., display an error message to the user)
        return null;
    }
}
```

### Next.js

#### File Organization

-   Use the `pages` directory for defining routes.
-   Use the `public` directory for static assets.
-   Create API routes in the `pages/api` directory.

#### API Routes

-   Handle API requests using asynchronous functions.
-   Return JSON responses with appropriate status codes.
-   Validate request data to prevent errors and security vulnerabilities.

```typescript
// MUST: Example of a Next.js API route
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method === 'POST') {
        try {
            const { prompt } = req.body;
            // Call OpenAI or Gemini API here
            const improvedPrompt = `Improved: ${prompt}`; // Replace with actual AI call
            res.status(200).json({ improvedPrompt });
        } catch (error: any) {
            console.error('API error:', error);
            res.status(500).json({ error: 'Failed to improve prompt' });
        }
    } else {
        res.status(405).json({ error: 'Method not allowed' });
    }
}
```

### Chakra UI

#### Component Usage

-   Use Chakra UI components for consistent styling and accessibility.
-   Customize components using theme tokens and style props.
-   Avoid creating custom CSS for common UI elements.

#### Theme Customization

-   Extend the default Chakra UI theme to match the application's design.
-   Define custom colors, fonts, and breakpoints in the theme.
-   Use semantic tokens for consistent styling across components.

### LocalStorage

#### Data Handling

-   Use `localStorage.setItem` to store data and `localStorage.getItem` to retrieve data.
-   Serialize and deserialize data using `JSON.stringify` and `JSON.parse`.
-   Handle potential errors when accessing `localStorage`.
-   Be mindful of storage limits and avoid storing large amounts of data.

```typescript
// MUST: Example of using LocalStorage
function saveApiKey(key: string) {
    try {
        localStorage.setItem('apiKey', JSON.stringify(key));
    } catch (error: any) {
        console.error('Failed to save API key:', error);
    }
}

function getApiKey(): string | null {
    try {
        const apiKey = localStorage.getItem('apiKey');
        return apiKey ? JSON.parse(apiKey) : null;
    } catch (error: any) {
        console.error('Failed to get API key:', error);
        return null;
    }
}
```

### Fetch API

#### Request Configuration

-   Set appropriate headers for API requests (e.g., `Content-Type: application/json`).
-   Handle different HTTP methods (GET, POST, PUT, DELETE) correctly.
-   Use `try...catch` blocks for error handling.

#### Response Handling

-   Check the response status code to ensure the request was successful.
-   Parse JSON responses using `response.json()`.
-   Handle errors gracefully and provide informative messages to the user.

## 4. Code Style Rules

### MUST Follow:

-   **Consistent Indentation**: Use 2 spaces for indentation. Rationale: Improves readability and reduces merge conflicts.
-   **Meaningful Names**: Use descriptive names for variables, functions, and components. Rationale: Enhances code understanding and maintainability.
-   **Single Responsibility Principle**: Each function/component should have a single, well-defined purpose. Rationale: Simplifies testing and reduces complexity.
-   **Comments**: Add comments to explain complex logic or non-obvious code. Rationale: Aids in understanding and maintaining the code.
-   **Error Handling**: Implement proper error handling with `try...catch` blocks and error boundaries. Rationale: Prevents application crashes and provides informative error messages.
-   **Use Typescript**: Use Typescript for all Javascript files to ensure type safety. Rationale: helps to prevent bugs.

### MUST NOT Do:

-   **Global Variables**: Avoid using global variables. Rationale: Can lead to naming conflicts and unexpected behavior.
-   **Magic Numbers**: Avoid using hardcoded values without explanation. Rationale: Makes code difficult to understand and maintain.
-   **Nested Callbacks**: Avoid deeply nested callbacks. Rationale: Reduces code readability and increases complexity (Callback Hell). Use async/await instead.
-   **Ignoring Errors**: Never ignore errors without handling them. Rationale: Can lead to unexpected behavior and difficult debugging.
-   **Console.log in Production**: Remove all `console.log` statements before deploying to production. Rationale: Avoids exposing sensitive information and reduces browser performance.

## 5. Architecture Patterns

### Component/Module Structure Guidelines

-   **Atomic Design**: Structure components using the Atomic Design methodology (Atoms, Molecules, Organisms, Templates, Pages).
-   **Container/Presentational Pattern**: Separate data fetching and logic from UI rendering.
-   **Component Composition**: Build complex components by composing smaller, reusable components.

### Data Flow Patterns

-   **Unidirectional Data Flow**: Data flows from parent components to child components via props.
-   **Event Handling**: Child components communicate with parent components via event handlers.
-   **API Calls**: Components fetch data from APIs using the Fetch API.

### State Management Conventions

-   **React Context API**: Use React Context API for managing global state (e.g., API key, user preferences).
-   **useState Hook**: Use the `useState` hook for managing local component state.
-   **useReducer Hook**: Use the `useReducer` hook for managing complex state transitions.
-   **Zustand (Alternative)**: Consider using Zustand for simpler global state management if Context API becomes too complex.

### API Design Standards

-   **RESTful APIs**: Design APIs following RESTful principles.
-   **JSON Format**: Use JSON for request and response bodies.
-   **Status Codes**: Use appropriate HTTP status codes to indicate the outcome of API requests.
-   **Error Handling**: Return informative error messages in the response body.
-   **Authentication**: Implement authentication to protect API endpoints (BYO API key strategy).

