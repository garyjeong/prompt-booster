{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품명\nPrompt Booster (가칭)\n\n# 요약\nPrompt Booster는 개인 개발자가 AI 코딩 도우미(ChatGPT·Gemini 등)에게 보낼 프롬프트를 자동으로 개선해 주는 초경량 웹 앱입니다. 반복적인 프롬프트 수정 시간을 절감하고 AI 응답 품질을 높여 개발 생산성을 극대화합니다.\n\n# 목표\n1. 개선된 프롬프트를 통해 원하는 코드를 한 번에 얻도록 돕는다.\n2. 프롬프트 작성 학습 곡선을 줄여 개인 개발자의 생산성을 높인다.\n3. 광고 기반 무료 모델로 사용 진입 장벽을 0으로 유지한다.\n\n# 핵심 지표 (Success Metrics)\n- D1 Retention ≥ 40%\n- 하루 평균 개선 프롬프트 생성 수 ≥ 10회/사용자\n- 개선된 프롬프트 복사율 ≥ 80%\n- 광고 노출 대비 클릭률(CTR) ≥ 1.5%\n\n# 타깃 사용자\n- 개인 개발자·프로그래머 (프리랜서, 사이드 프로젝트 개발자 포함)\n\n# 주요 사용 사례\n1. 버그 수정·디버깅 요청용 프롬프트 개선\n2. 코드 리뷰·리팩터링 요청용 프롬프트 개선\n3. 일반 코드 생성 요청용 프롬프트 개선\n\n# 사용자 pain point\n- 반복적인 프롬프트 수정으로 시간·집중력이 낭비된다.\n- 프롬프트가 비효율적이라 AI가 엉뚱한 답을 준다.\n- 효과적인 프롬프트 작성법을 잘 몰라 학습 곡선이 크다.\n\n# 기능 범위\n## MVP (v0.1)\n1. 개선된 프롬프트 생성기\n   - 사용자가 원본 프롬프트 입력 → AI에게 최적화 요청 → 개선된 프롬프트 표시\n   - OpenAI GPT-4/3.5 및 Google Gemini 1.5 Pro API 키 즉시 주입 기능\n2. 원-클릭 복사 버튼 (부가 기능이지만 구현 비용이 매우 낮아 포함)\n3. 광고 배너 로드(AdMob, AdFit) 및 위치 제어\n\n## 이후 릴리스 후보 (Backlog)\n- 프롬프트 히스토리 뷰어/재사용\n- 베스트 프랙티스 가이드 팝업\n- 다크모드 토글\n- 다양한 AI 모델 스위치 UI (Claude 3 등)\n\n# 비기능 요구사항\n- 데이터는 브라우저 캐시(LocalStorage/IndexedDB)에만 저장, 서버 DB 없음\n- 개선 속도 < 2초(네트워크·API 제외 렌더 타임)\n- 모바일·데스크톱 반응형 지원\n- 개인정보 미수집·쿠키 최소화\n\n# 제약 사항\n- 서버리스 구조를 우선 고려 (Vercel, Netlify 등)\n- 무료 API 키를 입력하지 않은 사용자는 데모 모드(제한된 글자 수)만 지원\n\n# 가정 및 리스크\n- 광고 수익이 서버 비용을 상쇄할 만큼 발생한다는 가정\n- AI API 비용이 사용자 수에 비례해 급증할 위험 → BYO API Key 전략으로 상쇄\n\n# 출시 로드맵\n1. Week 1 : UI/UX 디자인 및 핵심 로직(Prototyping)\n2. Week 2 : OpenAI·Gemini API 연동, 광고 삽입\n3. Week 3 : 베타 오픈 → 피드백 수집\n4. Week 4 : 버그 수정, 성능 최적화 → v0.1 공식 런칭\n\n# 성공 시나리오\n- 개인 개발자 커뮤니티(OKKY·Velog)에서 긍정 리뷰 획득\n- 소셜 버즈 및 트래픽 증가로 광고 수익이 서버 비용을 초과\n\n# 실패 시나리오\n- AI 모델 호출 지연으로 UX 불만 → 리팩터링 필요\n- 광고 과다 배치로 사용자 이탈 → 배치 위치 조정 및 A/B Test",
      "writedAt": "2025-09-04T10:51:06.669Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: Prompt Booster는 Next.js 기반의 초경량 웹 앱으로, 개인 개발자가 AI 코딩 도우미에 입력할 프롬프트를 자동으로 개선하여 생산성을 향상시키는 데 목표를 둡니다. 사용자 친화적인 UI와 광고 기반 무료 모델을 통해 접근성을 높이고, 로컬 스토리지에 데이터를 저장하여 개인 정보 보호를 강화합니다.\n- **Core Technology Stack**: Next.js 14, TypeScript, Chakra UI, LocalStorage, Fetch API, react-google-adsense를 사용하여 빠르고 효율적인 개발 환경을 구축하고, 유지 보수성을 높입니다.\n- **Key Technical Objectives**:\n  - **성능**: 2초 이내의 빠른 응답 시간 (API 호출 시간 제외).\n  - **확장성**: 서버리스 환경을 통해 사용자 증가에 따른 자동 확장.\n  - **안정성**: LocalStorage를 활용한 데이터 관리로 데이터 손실 최소화.\n- **Critical Technical Assumptions**:\n  - 광고 수익이 서버 비용을 충당할 수 있을 것으로 가정합니다.\n  - OpenAI 및 Gemini API의 안정적인 가용성을 가정합니다.\n  - 사용자들은 개인 API 키를 제공하여 API 사용량 제한을 해결할 것으로 가정합니다.\n\n## 2. Tech Stack\n\n| Category              | Technology / Library   | Reasoning (Why it's chosen for this project)                                                                                                                                                                                                                                                                                                   |\n| --------------------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Framework             | Next.js 14             | 서버 사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG)을 지원하여 초기 로딩 속도 개선 및 SEO 최적화. 라우팅, API 핸들링 등의 기능을 내장하여 개발 생산성 향상.                                                                                                                                                                                              |\n| Language              | TypeScript               | 정적 타입 검사를 통해 런타임 오류 감소 및 코드 품질 향상. 코드 자동 완성 및 리팩토링 지원으로 개발 효율성 증대.                                                                                                                                                                                                                                    |\n| UI Library            | Chakra UI                | 재사용 가능한 컴포넌트 제공 및 쉬운 스타일링으로 UI 개발 속도 향상. 반응형 디자인을 위한 유연한 레이아웃 시스템 제공. 접근성 (Accessibility)을 고려한 컴포넌트 제공.                                                                                                                                                                         |\n| Data Storage          | LocalStorage             | 클라이언트 측 데이터 저장소로, 사용자 프롬프트 히스토리 및 API 키 저장에 사용. 서버 데이터베이스가 필요 없는 간단한 데이터 저장에 적합.                                                                                                                                                                                                       |\n| API Communication     | Fetch API                | 브라우저 내장 API로, OpenAI 및 Gemini API와 통신하는 데 사용. 별도의 라이브러리 설치 없이 사용 가능.                                                                                                                                                                                                                                           |\n| Advertisement         | react-google-adsense | Google AdSense 광고를 웹 앱에 쉽게 통합할 수 있도록 지원. 광고 노출 및 클릭률 추적을 위한 기능 제공.                                                                                                                                                                                                                                            |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js Application)**:\n  - **Components**: Chakra UI 기반의 UI 컴포넌트 (입력 폼, 버튼, 결과 패널 등).\n  - **Pages**: 메인 페이지 (프롬프트 입력 및 결과 표시), 히스토리 페이지 (최근 사용 프롬프트 목록).\n  - **State Management**: React Context API 또는 Zustand를 사용하여 UI 상태 관리 (API 키, 프롬프트 입력 값 등).\n- **API Layer (Serverless Functions)**:\n  - **OpenAI API**: OpenAI GPT-4/3.5 모델 호출을 위한 API 엔드포인트.\n  - **Google Gemini API**: Google Gemini 1.5 Pro 모델 호출을 위한 API 엔드포인트.\n- **Data Storage (LocalStorage)**:\n  - **API Key Storage**: OpenAI/Gemini API 키 저장.\n  - **Prompt History**: 최근 사용 프롬프트 저장 및 관리.\n- **Advertisement (react-google-adsense)**:\n  - **Ad Placement**: 페이지 하단 또는 사이드바에 광고 배너 삽입.\n  - **Ad Management**: 광고 노출 및 클릭률 추적.\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[User Interface (Next.js)] --> B[API Layer (Serverless Functions)]\n    B --> C[OpenAI API / Gemini API]\n    A --> D[LocalStorage]\n    A --> E[react-google-adsense]\n```\n\n- **User Interface (Next.js)**: 사용자의 입력을 받아 API Layer로 전달하고, 결과를 표시합니다. 또한, LocalStorage에 데이터를 저장하고, react-google-adsense를 통해 광고를 표시합니다.\n- **API Layer (Serverless Functions)**: Next.js API Routes를 통해 구현되며, OpenAI API 또는 Gemini API를 호출하여 프롬프트를 개선합니다.\n- **OpenAI API / Gemini API**: AI 모델을 통해 프롬프트를 개선하고 결과를 반환합니다.\n- **LocalStorage**: 사용자의 API 키와 프롬프트 히스토리를 저장합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**:\n    - `components`: UI 컴포넌트 (입력 폼, 결과 패널, 버튼 등).\n    - `pages`: Next.js 페이지 (메인 페이지, 히스토리 페이지).\n    - `lib`: 유틸리티 함수 (API 호출, LocalStorage 관리, 프롬프트 개선 로직).\n    - `context`: React Context API를 사용한 전역 상태 관리.\n\n**Universal File & Folder Structure**\n```\n/\n├── components/\n│   ├── PromptInput.tsx\n│   ├── PromptResult.tsx\n│   ├── CopyButton.tsx\n│   └── ...\n├── pages/\n│   ├── index.tsx\n│   └── history.tsx\n├── lib/\n│   ├── api.ts\n│   ├── localstorage.ts\n│   └── prompt.ts\n├── context/\n│   ├── ApiKeyContext.tsx\n│   └── ...\n├── public/\n│   ├── ...\n├── styles/\n│   ├── globals.css\n│   └── ...\n├── next.config.js\n└── tsconfig.json\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**:\n  - 사용자가 프롬프트를 입력하고 '개선하기' 버튼을 클릭하면, Frontend는 API Layer로 HTTP 요청을 보냅니다.\n  - API Layer는 OpenAI API 또는 Gemini API를 호출하고, 결과를 Frontend로 반환합니다.\n- **Database Interaction**:\n  - LocalStorage를 사용하여 API 키와 프롬프트 히스토리를 저장하고 검색합니다.\n- **External Service Integration**:\n  - OpenAI API 및 Gemini API를 Fetch API를 통해 호출합니다.\n  - react-google-adsense를 사용하여 Google AdSense 광고를 통합합니다.\n\n## 4. Performance & Optimization Strategy\n- **코드 분할 (Code Splitting)**: Next.js의 Dynamic Import를 사용하여 초기 로딩 속도를 개선합니다.\n- **이미지 최적화 (Image Optimization)**: Next.js의 Image 컴포넌트를 사용하여 이미지 크기를 최적화하고, 레이지 로딩을 적용합니다.\n- **메모이제이션 (Memoization)**: React.memo 또는 useMemo를 사용하여 불필요한 렌더링을 방지합니다.\n- **API 응답 캐싱 (API Response Caching)**: API 응답을 클라이언트 측에 캐싱하여 API 호출 횟수를 줄입니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 설정, Chakra UI 통합, 기본 레이아웃 구축.\n- **Essential Features**: 프롬프트 입력 폼, OpenAI/Gemini API 연동, 개선된 프롬프트 표시, 복사 버튼 구현.\n- **Basic Security**: LocalStorage에 API 키 저장 시 암호화 적용 (선택 사항).\n- **Development Setup**: 개발 환경 설정, ESLint/Prettier 설정, Git 저장소 생성.\n- **Timeline**: 1주차\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 프롬프트 히스토리 뷰어, 다크 모드 토글, 다양한 AI 모델 스위치 UI (Backlog 기능).\n- **Performance Optimization**: 코드 분할, 이미지 최적화, 메모이제이션 적용.\n- **Enhanced Security**: LocalStorage에 저장된 API 키 암호화.\n- **Monitoring Implementation**: Google Analytics를 사용하여 사용자 행동 분석.\n- **Timeline**: 2주차\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**:\n  - OpenAI/Gemini API의 응답 지연 또는 장애 발생 가능성.\n  - LocalStorage의 데이터 손실 가능성.\n- **Performance Risks**:\n  - API 호출 횟수 증가에 따른 성능 저하.\n  - 초기 로딩 속도 저하.\n- **Security Risks**:\n  - LocalStorage에 저장된 API 키 유출 가능성.\n- **Integration Risks**:\n  - react-google-adsense와의 호환성 문제.\n- **Mitigation Strategies**:\n  - API 응답 지연에 대비하여 타임아웃 설정 및 재시도 로직 구현.\n  - LocalStorage 데이터 백업 및 복구 기능 구현.\n  - API 응답 캐싱 및 코드 최적화를 통해 성능 개선.\n  - LocalStorage에 저장된 API 키 암호화.\n  - react-google-adsense 최신 버전 사용 및 호환성 테스트.\n\n### Project Delivery Risks\n- **Timeline Risks**:\n  - OpenAI/Gemini API 연동 지연.\n  - UI 디자인 및 개발 지연.\n- **Resource Risks**:\n  - 개발 인력 부족.\n- **Quality Risks**:\n  - 코드 품질 저하.\n  - 테스트 부족.\n- **Deployment Risks**:\n  - Vercel/Netlify 배포 실패.\n- **Contingency Plans**:\n  - OpenAI/Gemini API 연동 지연 시 대체 API 사용 또는 데모 모드 제공.\n  - UI 디자인 및 개발 지연 시 MVP 기능 우선 구현.\n  - 추가 개발 인력 투입 또는 외부 전문가 활용.\n  - 코드 리뷰 및 충분한 테스트 수행.\n  - Vercel/Netlify 배포 문제 발생 시 다른 서버리스 플랫폼 사용.\n",
      "writedAt": "2025-09-04T10:51:06.669Z"
    },
    {
      "type": "guideline",
      "content": "# Prompt Booster Code Guidelines\n\n## 1. Project Overview\n\nPrompt Booster is a lightweight web application built with Next.js that enhances prompts for AI coding assistants. It aims to improve developer productivity by optimizing prompts for better AI responses. The application uses a serverless architecture and stores data locally in the browser.\n\nKey architectural decisions:\n\n-   **Next.js**: For SSR/SSG, routing, and API handling.\n-   **TypeScript**: For static typing and code quality.\n-   **Chakra UI**: For rapid UI development with reusable components.\n-   **LocalStorage**: For client-side data persistence.\n-   **Serverless Functions**: For API endpoints interacting with OpenAI/Gemini.\n\n## 2. Core Principles\n\n-   **Maintainability**: Code should be easy to understand, modify, and debug.\n-   **Performance**: Application should respond quickly and efficiently.\n-   **Readability**: Code should be clear and self-documenting.\n-   **Testability**: Code should be designed to be easily tested.\n-   **Consistency**: Follow established patterns and conventions throughout the project.\n\n## 3. Language-Specific Guidelines\n\n### TypeScript\n\n#### File Organization and Directory Structure\n\n-   Group related files into feature-based directories.\n-   Use PascalCase for component filenames (e.g., `PromptInput.tsx`).\n-   Use camelCase for function and variable names.\n\n#### Import/Dependency Management\n\n-   Use absolute imports for project modules (e.g., `import PromptInput from 'components/PromptInput'`).\n-   Install dependencies using `npm install` or `yarn add`.\n-   Keep `package.json` clean and up-to-date.\n\n#### Error Handling Patterns\n\n-   Use `try...catch` blocks for handling potential errors in asynchronous operations (e.g., API calls).\n-   Implement error boundaries for catching errors in React components.\n-   Log errors with sufficient context for debugging.\n\n```typescript\n// MUST: Example of try...catch for API calls\nasync function fetchPrompt(prompt: string) {\n    try {\n        const response = await fetch('/api/improve', {\n            method: 'POST',\n            body: JSON.stringify({ prompt }),\n            headers: { 'Content-Type': 'application/json' },\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data.improvedPrompt;\n    } catch (error: any) {\n        console.error('Failed to fetch prompt:', error);\n        // Handle the error appropriately (e.g., display an error message to the user)\n        return null;\n    }\n}\n```\n\n### Next.js\n\n#### File Organization\n\n-   Use the `pages` directory for defining routes.\n-   Use the `public` directory for static assets.\n-   Create API routes in the `pages/api` directory.\n\n#### API Routes\n\n-   Handle API requests using asynchronous functions.\n-   Return JSON responses with appropriate status codes.\n-   Validate request data to prevent errors and security vulnerabilities.\n\n```typescript\n// MUST: Example of a Next.js API route\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n    if (req.method === 'POST') {\n        try {\n            const { prompt } = req.body;\n            // Call OpenAI or Gemini API here\n            const improvedPrompt = `Improved: ${prompt}`; // Replace with actual AI call\n            res.status(200).json({ improvedPrompt });\n        } catch (error: any) {\n            console.error('API error:', error);\n            res.status(500).json({ error: 'Failed to improve prompt' });\n        }\n    } else {\n        res.status(405).json({ error: 'Method not allowed' });\n    }\n}\n```\n\n### Chakra UI\n\n#### Component Usage\n\n-   Use Chakra UI components for consistent styling and accessibility.\n-   Customize components using theme tokens and style props.\n-   Avoid creating custom CSS for common UI elements.\n\n#### Theme Customization\n\n-   Extend the default Chakra UI theme to match the application's design.\n-   Define custom colors, fonts, and breakpoints in the theme.\n-   Use semantic tokens for consistent styling across components.\n\n### LocalStorage\n\n#### Data Handling\n\n-   Use `localStorage.setItem` to store data and `localStorage.getItem` to retrieve data.\n-   Serialize and deserialize data using `JSON.stringify` and `JSON.parse`.\n-   Handle potential errors when accessing `localStorage`.\n-   Be mindful of storage limits and avoid storing large amounts of data.\n\n```typescript\n// MUST: Example of using LocalStorage\nfunction saveApiKey(key: string) {\n    try {\n        localStorage.setItem('apiKey', JSON.stringify(key));\n    } catch (error: any) {\n        console.error('Failed to save API key:', error);\n    }\n}\n\nfunction getApiKey(): string | null {\n    try {\n        const apiKey = localStorage.getItem('apiKey');\n        return apiKey ? JSON.parse(apiKey) : null;\n    } catch (error: any) {\n        console.error('Failed to get API key:', error);\n        return null;\n    }\n}\n```\n\n### Fetch API\n\n#### Request Configuration\n\n-   Set appropriate headers for API requests (e.g., `Content-Type: application/json`).\n-   Handle different HTTP methods (GET, POST, PUT, DELETE) correctly.\n-   Use `try...catch` blocks for error handling.\n\n#### Response Handling\n\n-   Check the response status code to ensure the request was successful.\n-   Parse JSON responses using `response.json()`.\n-   Handle errors gracefully and provide informative messages to the user.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n-   **Consistent Indentation**: Use 2 spaces for indentation. Rationale: Improves readability and reduces merge conflicts.\n-   **Meaningful Names**: Use descriptive names for variables, functions, and components. Rationale: Enhances code understanding and maintainability.\n-   **Single Responsibility Principle**: Each function/component should have a single, well-defined purpose. Rationale: Simplifies testing and reduces complexity.\n-   **Comments**: Add comments to explain complex logic or non-obvious code. Rationale: Aids in understanding and maintaining the code.\n-   **Error Handling**: Implement proper error handling with `try...catch` blocks and error boundaries. Rationale: Prevents application crashes and provides informative error messages.\n-   **Use Typescript**: Use Typescript for all Javascript files to ensure type safety. Rationale: helps to prevent bugs.\n\n### MUST NOT Do:\n\n-   **Global Variables**: Avoid using global variables. Rationale: Can lead to naming conflicts and unexpected behavior.\n-   **Magic Numbers**: Avoid using hardcoded values without explanation. Rationale: Makes code difficult to understand and maintain.\n-   **Nested Callbacks**: Avoid deeply nested callbacks. Rationale: Reduces code readability and increases complexity (Callback Hell). Use async/await instead.\n-   **Ignoring Errors**: Never ignore errors without handling them. Rationale: Can lead to unexpected behavior and difficult debugging.\n-   **Console.log in Production**: Remove all `console.log` statements before deploying to production. Rationale: Avoids exposing sensitive information and reduces browser performance.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n-   **Atomic Design**: Structure components using the Atomic Design methodology (Atoms, Molecules, Organisms, Templates, Pages).\n-   **Container/Presentational Pattern**: Separate data fetching and logic from UI rendering.\n-   **Component Composition**: Build complex components by composing smaller, reusable components.\n\n### Data Flow Patterns\n\n-   **Unidirectional Data Flow**: Data flows from parent components to child components via props.\n-   **Event Handling**: Child components communicate with parent components via event handlers.\n-   **API Calls**: Components fetch data from APIs using the Fetch API.\n\n### State Management Conventions\n\n-   **React Context API**: Use React Context API for managing global state (e.g., API key, user preferences).\n-   **useState Hook**: Use the `useState` hook for managing local component state.\n-   **useReducer Hook**: Use the `useReducer` hook for managing complex state transitions.\n-   **Zustand (Alternative)**: Consider using Zustand for simpler global state management if Context API becomes too complex.\n\n### API Design Standards\n\n-   **RESTful APIs**: Design APIs following RESTful principles.\n-   **JSON Format**: Use JSON for request and response bodies.\n-   **Status Codes**: Use appropriate HTTP status codes to indicate the outcome of API requests.\n-   **Error Handling**: Return informative error messages in the response body.\n-   **Authentication**: Implement authentication to protect API endpoints (BYO API key strategy).\n",
      "writedAt": "2025-09-04T10:51:06.669Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-04T10:51:06.669Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-04T10:51:06.669Z"
    }
  ]
}